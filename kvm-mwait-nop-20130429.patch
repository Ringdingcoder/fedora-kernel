##############################################################################
# kvm-mwait-nop-20130313.patch (Gabriel Somlo <somlo@cmu.edu>)
# DESCRIPTION: Emulate both MONITOR and MWAIT as NOP
# NOTE: This is architecturally clean behavior, but will prevent idle
#        loops based on MWAIT from ever relinguishing host CPU resources.
#       For instance, Mac OS X will operate correctly, but in order to allow
#        the host CPU utilization to drop when idle, one would need to remove
#        /System/Library/Extensions/AppleIntelCPUPowerManagement.kext, which
#        then causes OS X to revert to a HLT-based idle loop.
##############################################################################
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index a20ecb5..71783d4 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -225,6 +225,16 @@ static int do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,
 		0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);
 	/* cpuid 1.ecx */
 	const u32 kvm_supported_word4_x86_features =
+		/* OS X does not check CPUID before using MONITOR/MWAIT from its
+		 * power-optimized idle loop (AppleIntelPowerManagement.kext).
+		 * For now, we don't advertise MWAIT support below, but handle
+		 * them as NOP instead of issuing an invalid opcode fault if a
+		 * misbehaving guest calls them anyway. This behavior is clean
+		 * from an architectural standpoint, even though it will keep
+		 * the guest from yielding resources when idle. Removing the
+		 * above mentioned kext from OS X will cause it to fall back
+		 * to a HLT-based idle loop, as an optional guest optimization.
+		 */
 		F(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |
 		0 /* DS-CPL, VMX, SMX, EST */ |
 		0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index e1b1ce2..b1f626b 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -3259,6 +3259,12 @@ static int pause_interception(struct vcpu_svm *svm)
 	return 1;
 }
 
+static int nop_interception(struct vcpu_svm *svm)
+{
+	skip_emulated_instruction(&(svm->vcpu));
+	return 1;
+}
+
 static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {
 	[SVM_EXIT_READ_CR0]			= cr_interception,
 	[SVM_EXIT_READ_CR3]			= cr_interception,
@@ -3316,8 +3322,8 @@ static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {
 	[SVM_EXIT_CLGI]				= clgi_interception,
 	[SVM_EXIT_SKINIT]			= skinit_interception,
 	[SVM_EXIT_WBINVD]                       = emulate_on_interception,
-	[SVM_EXIT_MONITOR]			= invalid_op_interception,
-	[SVM_EXIT_MWAIT]			= invalid_op_interception,
+	[SVM_EXIT_MONITOR]			= nop_interception,
+	[SVM_EXIT_MWAIT]			= nop_interception,
 	[SVM_EXIT_XSETBV]			= xsetbv_interception,
 	[SVM_EXIT_NPF]				= pf_interception,
 };
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 6667042..51fe874 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -5220,6 +5220,12 @@ static int handle_pause(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+static int handle_nop(struct kvm_vcpu *vcpu)
+{
+	skip_emulated_instruction(vcpu);
+	return 1;
+}
+
 static int handle_invalid_op(struct kvm_vcpu *vcpu)
 {
 	kvm_queue_exception(vcpu, UD_VECTOR);
@@ -5901,8 +5907,8 @@ static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[EXIT_REASON_EPT_VIOLATION]	      = handle_ept_violation,
 	[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,
 	[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,
-	[EXIT_REASON_MWAIT_INSTRUCTION]	      = handle_invalid_op,
-	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,
+	[EXIT_REASON_MWAIT_INSTRUCTION]	      = handle_nop,
+	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_nop,
 	[EXIT_REASON_INVEPT]                  = handle_invept,
 };
 
 static const int kvm_vmx_max_exit_handlers =
##############################################################################
# ioapic-polarity.patch.kvm-kmod (Alexander Graf <agraf@suse.de>)
# GLS: enables OS X to get past "still waiting for root device" loop on boot
# TODO: understand io/apic irq level polarity and how to maybe fix this at
#       the Chameleon/SeaBIOS/QEMU level;
##############################################################################
diff --git a/virt/kvm/ioapic.c b/virt/kvm/ioapic.c
index 5ba005c..f0177f3 100644
--- a/virt/kvm/ioapic.c
+++ b/virt/kvm/ioapic.c
@@ -238,7 +238,9 @@ int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,
 	irq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],
 					 irq_source_id, level);
 	entry = ioapic->redirtbl[irq];
+/* from OS X patch by agraf@suse.de: "polarity is always active-high in qemu"
 	irq_level ^= entry.fields.polarity;
+*/
 	if (!irq_level) {
 		ioapic->irr &= ~mask;
 		ret = 1;
